# up_recurs_ss_cython.pyx
# Cython version of up_recurs_ss

from libc.stdlib cimport malloc, free
import numpy as np
cimport numpy as np

cpdef void up_recurs_ss_cython(
    int curr,
    object dr_net,
    object dr_pt,
    object dr_pt_in
):
    """
    Cython-optimized version of up_recurs_ss to compute downslope path lengths
    in the subsurface drainage graph.

    Parameters
    ----------
    curr : int
        Current drainage network ID (1-based).
    dr_net : list of DrainageNetwork
        Drainage networks containing lengths, paths, etc.
    dr_pt : list of DrainagePoint
        Drainage points with upl, dpl.
    dr_pt_in : list of DrainagePointInflow
        Tracks inflows and their multiplicity.
    """
    cdef int cnt_pt, id_dr, end_el, in_curr
    cdef float l1, l2, l3

    end_el = dr_net[curr - 1].nel

    for cnt_pt in range(end_el - 1, 0, -1):
        id_dr = dr_net[curr - 1].id_pnts.value[cnt_pt - 1]
        l1 = dr_net[curr - 1].length
        l2 = dr_pt[id_dr - 1].upl
        l3 = dr_pt[dr_net[curr - 1].id_pnts.value[end_el - 1] - 1].dpl

        dr_pt[id_dr - 1].dpl = l1 - l2 + l3

        if dr_pt_in[id_dr - 1].ninf > 1:
            for in_curr in dr_pt_in[id_dr - 1].inflow:
                if in_curr != curr:
                    dr_net[in_curr - 1].n_path = dr_net[curr - 1].n_path + 1
                    dr_net[in_curr - 1].id_path = [dr_net[in_curr - 1].id_ch.value]
                    dr_net[in_curr - 1].id_path.extend(
                        dr_net[curr - 1].id_path[:dr_net[in_curr - 1].n_path - 1]
                    )
                    up_recurs_ss_cython(in_curr, dr_net, dr_pt, dr_pt_in)
